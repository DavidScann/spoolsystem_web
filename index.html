<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/style.css">
    <title>spool.systems</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
</head>
<body>
    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script type="module">

        import { Application, Sprite, Assets, TextureStyle, Container, Text, TextStyle, Graphics, Ticker } from 'pixi.js';
        import { CRTFilter, AdvancedBloomFilter, RGBSplitFilter } from 'pixi-filters';
        // import { FancyButton } from '@pixi/ui';

        // WebFont loading
        WebFont.load({
            google: {
              families: ['Roboto Mono'],
            }
          });

        // PIXI App Initialization
        const app = new Application();
        await app.init(
            {
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x000000,
                resizeTo: window, // Auto-resize canvas to the window
            }
        );
        document.body.appendChild(app.canvas);

        // Apply filters to the stage
        app.stage.filters = [
            new CRTFilter(),
            new RGBSplitFilter({
                redX: 3,
                redY: 1,
                blueX: 0,
                blueY: 0,
                greenX: -3,
                greenY: -1,
            }),
            new AdvancedBloomFilter({
                bloomScale: 1.4,
                blur: 10,
                padding: 500,
            }),
        ];

        // Global PIXI app reference for debugging
        globalThis.__PIXI_APP__ = app;

        // Set texture scaling to nearest neighbor
        TextureStyle.defaultOptions.scaleMode = 'nearest';

        // State to track the currently selected flag
        let selectedFlag = null;

        // Sprite resizing function
        function resizeFlags(sprite, xPositionFactor = 0.5, containerWidth, containerHeight) {
            if (containerWidth === undefined || containerHeight === undefined) {
                containerWidth = window.innerWidth;
                containerHeight = window.innerHeight;
            }
        
            // Calculate scale to maintain aspect ratio
            const scaleWidth = containerWidth / sprite.texture.width;
            const scaleHeight = containerHeight / sprite.texture.height;
            const scaleFactor = Math.min(scaleWidth, scaleHeight) * 0.14;
        
            // Apply scaling
            sprite.scale.set(scaleFactor);
        
            // Adjust position based on screen width
            if (containerWidth < 600) { // Adjust this value as needed
                // Align vertically
                sprite.x = containerWidth / 2;
                sprite.y = containerHeight * xPositionFactor;
            } else {
                // Align horizontally
                sprite.x = containerWidth * xPositionFactor;
                sprite.y = containerHeight / 2;
            }
        }

        // Setting up a container for Flags
        const flagsRender = new Container({
            isRenderGroup: true
        });

        // Function to load and setup a sprite
        async function setupFlags(imagePath, xPositionFactor = 0.5) {
            await Assets.load(imagePath); // Preload the texture
            const sprite = Sprite.from(imagePath);
            sprite.anchor.set(0.5);
            sprite.alpha = 0.4;
            sprite.interactive = true;
            sprite.buttonFrameMode = true;
            sprite.cursor = 'pointer';

            // Flicker logic
            let flickerDuration = 220;
            let flickerInterval = 25;
            let targetAlpha = sprite.alpha;
            let flickering = false;
            let flickerTimer = 0;

            app.ticker.add(() => {
                if (flickering) {
                    flickerTimer += app.ticker.deltaMS;
                    if (Math.floor(flickerTimer / flickerInterval) % 2 === 0) {
                        sprite.alpha = 1;
                    } else {
                        sprite.alpha = 0.1 + (flickerTimer / flickerDuration);
                    }

                    if (flickerTimer >= flickerDuration) {
                        flickering = false;
                        flickerTimer = 0;
                        sprite.alpha = targetAlpha;
                    }
                }
            });

            sprite.on('pointerenter', () => {
                if (sprite !== selectedFlag) {
                    flickering = true;
                    flickerTimer = 0;
                    targetAlpha = 1;
                }
            });

            sprite.on('pointerleave', () => {
                if (sprite !== selectedFlag) {
                    flickering = true;
                    flickerTimer = 0;
                    targetAlpha = 0.4;
                }
            });

            sprite.on('pointerdown', () => {
                selectFlag(sprite);
            });

            resizeFlags(sprite, xPositionFactor);
            flagsRender.addChild(sprite);
            return sprite;
        }

        let flagMoved = false;
        // Function to select a flag
        function selectFlag(flag) {
            if (selectedFlag) {
                selectedFlag.alpha = 0.4; // Deselect current flag
            }
            selectedFlag = flag;
            selectedFlag.alpha = 1; // Keep alpha at 1 for the selected flag
            if (flagMoved != true) {
                animateFlagsRenderUpwards();
                flagMoved = true;
            }
            if (textSpawn != true) {
                disclaimerText(selectedFlag);
                textSpawn = true;
            }
            else {
                if (selectedFlag === flagGB) {
                    langDisclaimerText = GBLangDisclaimerText;
                }
                else {
                    langDisclaimerText = VNLangDisclaimerText;
                }
                cookieDisclaimerText.text = langDisclaimerText;
                resizeDisclaimer(cookieDisclaimerText, window.innerWidth, window.innerHeight);
            }
            if (buttonCreated != true) {
                createButtonFrame(selectedFlag);
                buttonCreated = true;
            }
            else {
                if (selectedFlag === flagGB) {
                    langButtonText = GBButtonText;
                }
                else {
                    langButtonText = VNButtonText;
                }
                buttonFrameText.text = langButtonText;
            }
            
        }

        // Function to animate the flagsRender container upwards
function animateFlagsRenderUpwards() {
    const startY = flagsRender.y; // Current position
    const targetY = startY - 50; // Move up by 50 pixels
    const duration = 1250; // Animation duration in milliseconds
    const easing = (t) => 1 - Math.pow(2, -10 * t); // Ease-out Exponential function

    let elapsedTime = 0;

    // Add a ticker to animate the movement
    const flagTicker = new Ticker()
    flagTicker.add((delta) => {
        elapsedTime += flagTicker.deltaMS;

        // Calculate the current progress (0 to 1)
        const progress = Math.min(elapsedTime / duration, 1);

        // Apply easing
        const easedProgress = easing(progress);

        // Update the container's position
        flagsRender.y = startY + (targetY - startY) * easedProgress;
            });
        flagTicker.start();
    };
        const GBLangDisclaimerText = "THIS SITE USES COOKIES TO \nSAVE YOUR PROGRESS. CONTINUE?";
        const VNLangDisclaimerText = "WEBSITE NÀY SỬ DỤNG COOKIES ĐỂ \nLƯU QUÁ TRÌNH CỦA BẠN. TIẾP TỤC?";
        let cookieDisclaimerText;
        let textSpawn = false;
        let langDisclaimerText;
        function disclaimerText(flag) {
            const style = new TextStyle({
                fontFamily: 'Roboto Mono',
                fontSize: 20,
                fill: '0xffffff',
            });
            if (flag === flagGB) {
                langDisclaimerText = GBLangDisclaimerText;
            } else {
                langDisclaimerText = VNLangDisclaimerText;
            }
            cookieDisclaimerText = new Text(
                {
                    text: langDisclaimerText,
                    style   
                } 
            );
            cookieDisclaimerText.anchor.set(0.5);
            cookieDisclaimerText.alpha = 0; // Set initial alpha to 0
            resizeDisclaimer(cookieDisclaimerText, window.innerWidth, window.innerHeight);
            animateDisclaimerText(cookieDisclaimerText, window.innerWidth, window.innerHeight);
            app.stage.addChild(cookieDisclaimerText);
        }

        function resizeDisclaimer(text, containerWidth, containerHeight) {
            // Ensure word wrap is enabled
            // text.style.wordWrap = true;
            // text.style.wordWrapWidth = containerWidth;
        
            // Initial scaling factor
            let scaleFactor = Math.min(containerWidth / text.width, containerHeight / text.height) / 5;
        
            // Apply initial scaling
            text.style.fontSize *= scaleFactor;
        
            // Adjust position
            text.x = containerWidth / 2;
            text.y = containerHeight / 1.65;

            // Check dimensions and adjust font size iteratively if needed
            while (text.width > containerWidth || text.height > containerHeight) {
                text.style.fontSize *= 0.9; // Decrease font size by 10%
                text.text = text.text; // Trigger text update
            }

            // Set a minimum font size
            const minFontSize = 14; // Adjust this value as needed
            if (text.style.fontSize < minFontSize) {
                text.style.fontSize = minFontSize;
            }
            console.log(text.style.fontSize);
        }

        function animateDisclaimerText(text, containerWidth, containerHeight) {
            const startY = text.y - 50; // Current position
            const targetY = startY + 50; // Move up by 50 pixels
            const duration = 1250; // Animation duration in milliseconds
            const easing = (t) => 1 - Math.pow(2, -10 * t); // Ease-out Exponential function
        
            let elapsedTime = 0;
        
            // Add a ticker to animate the movement
            const cookieTicker = new Ticker()
            cookieTicker.add((delta) => {
                elapsedTime += cookieTicker.deltaMS;
        
                // Calculate the current progress (0 to 1)
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Raise alpha from 0 to 1
                if (progress < 0.5) {
                    text.alpha = progress * 2;
                }

                // Apply easing
                const easedProgress = easing(progress);
        
                // Update the container's position
                text.y = startY + (targetY - startY) * easedProgress;
         
                // Stop the animation when it's done
                if (progress >= 1) {
                    cookieTicker.destroy(); // Remove the ticker
                }
            });
            cookieTicker.start();
        }

        // Initialize and place sprites
        let flagGB, flagVN;
        async function initSprites() {
            flagGB = await setupFlags('/assets/flaggb_lowres.png', 0.4);
            flagVN = await setupFlags('/assets/flagvn_lowres.png', 0.6);
        }

        await initSprites();

        // Add container to the stage
        app.stage.addChild(flagsRender);

        const cookieButton = new Container({
            isRenderGroup: true
        });

        const buttonWidth = window.innerWidth / 7;
        const buttonHeight = window.innerHeight / 12;
        const GBButtonText = 'CONTINUE';
        const VNButtonText = 'TIẾP TỤC';
        let langButtonText, buttonCreated, buttonFrameText;
        const buttonFrame = new Graphics();
        function createButtonFrame(flag) {
            buttonFrame.rect(0, 0, buttonWidth, buttonHeight);
            buttonFrame.fill(
                {
                    alpha: 0,
                    color: 0x8c8c8c
                });
            buttonFrame.stroke({
                color: 0xffffff,
                alpha: 1,
                width: 5
            });

            buttonFrame.interactive = true;
            buttonFrame.buttonMode = true;
            buttonFrame.cursor = 'pointer';
            buttonFrame.on('pointerdown', () => {
                console.log('Button was clicked!');
            });
            buttonFrame.x = (window.innerWidth - buttonFrame.width) / 2;
            buttonFrame.y = (window.innerHeight - buttonFrame.height) / 1.35;
            cookieButton.addChild(buttonFrame);
            if (flag === flagGB) {
                langButtonText = GBButtonText;
            } else {
                langButtonText = VNButtonText;
            }
            // Add "Continue" text in the middle of the frame
            const style = new TextStyle({
                fontFamily: 'Roboto Mono',
                fontSize: 20,
                fill: '0xffffff',
            });
            buttonFrameText = new Text(
                {
                    text: langButtonText,
                    style
                } 
                );
            buttonFrameText.anchor.set(0.5);
            buttonFrameText.x = buttonFrame.x + buttonWidth / 2;
            buttonFrameText.y = buttonFrame.y + buttonHeight / 2;   
            
            setTimeout(() => {
                animateCookieButton(cookieButton);
                cookieButton.addChild(buttonFrameText);
                app.stage.addChild(cookieButton);
            }, 600);
        }

        function resizeButton(buttonFrame, buttonFrameText, containerWidth, containerHeight) {
            // Calculate new button dimensions based on container size
            const newButtonWidth = containerWidth / 7;
            const newButtonHeight = containerHeight / 12;
        
            // Update button frame dimensions
            buttonFrame.clear();
            buttonFrame.beginFill(0x8c8c8c, 0);
            buttonFrame.lineStyle(5, 0xffffff, 1);
            buttonFrame.drawRect(0, 0, newButtonWidth, newButtonHeight);
            buttonFrame.endFill();
        
            // Update button frame position
            buttonFrame.x = (containerWidth - newButtonWidth) / 2;
            buttonFrame.y = (containerHeight - newButtonHeight) / 1.35;
        
        
            // Update button text position
            buttonFrameText.anchor.set(0.5); // Center the text
            buttonFrameText.x = buttonFrame.x + newButtonWidth / 2;
            buttonFrameText.y = buttonFrame.y + newButtonHeight / 2;

            // Update button text font
            buttonFrameText.style.fontSize = Math.min(newButtonWidth, newButtonHeight) / 4;

            // Ensure the text is centered after resizing
            buttonFrameText.x = buttonFrame.x + newButtonWidth / 2;
            buttonFrameText.y = buttonFrame.y + newButtonHeight / 2;
        }

        function animateCookieButton(cookieButton) {
            const startY = cookieButton.y - 50; // Current position
            const targetY = startY + 50; // Move up by 50 pixels
            const duration = 1250; // Animation duration in milliseconds
            const easing = (t) => 1 - Math.pow(2, -10 * t); // Ease-out Exponential function
        
            let elapsedTime = 0;
        
            // Add a ticker to animate the movement
            const ticker = app.ticker.add((delta) => {
                elapsedTime += app.ticker.deltaMS;
        
                // Calculate the current progress (0 to 1)
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Raise alpha from 0 to 1
                if (progress < 0.5) {
                    cookieButton.alpha = progress * 2;
                }

                // Apply easing
                const easedProgress = easing(progress);
        
                // Update the container's position
                cookieButton.y = startY + (targetY - startY) * easedProgress;
        
                // Stop the animation when it's done
                if (progress >= 1) {
                    // ticker.stop(); // Remove the ticker
                }
            });
            }

        // Handle resizing
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            resizeFlags(flagGB, 0.4, containerWidth, containerHeight);
            resizeFlags(flagVN, 0.6, containerWidth, containerHeight);
            resizeDisclaimer(cookieDisclaimerText, containerWidth, containerHeight);
            resizeButton(buttonFrame, buttonFrameText, containerWidth, containerHeight);
        });
    </script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block; /* Prevent extra whitespace */
        }
    </style>
</body>
</html>
